{"name":"Episerver.libraries","tagline":"Libraries for use within EPiServer projects","body":"﻿# A custom localization provider for EPiServer 7. \r\n\r\nBy Jeroen Stemerdink\r\n\r\n## About\r\n\r\nI wanted Editors to be able to change translations on their own, with no fear of loadbalancers / file replication making a mess of things. So it needed to be done within EPiServer itself, not with a plugin in admin mode, but in the content tree.\r\n\r\nI created three PageTypes. \r\n\r\n* ```TranslationContainer``` for normal translations\r\n* ```CategoryTranslationContainer``` for translations of Categories (as the xml for those translations are slightly different from a normal translation).\r\n* ```Translation Item``` a translation\r\n\r\nTo be able to use the translations created within the website, I created a ```TranslationProvider```, which is based on the XmlLocalizationProvider from EPiServer 7.\r\n\r\nThe provider gets initialiazed through an IInitializableModule,```TranslationProviderInitialization ```, so no configuration is necessary and gets its data from the “TranslationFactory”.\r\n\r\n## Get started\r\n\r\nYou start with creating a ```TranslationContainer``` underneath the ```StartPage```, or wherever you want. \r\n\r\nIf you want to put the container somewhere else, you will need to set a property of type ```PageReference``` on the ```StartPage```, surprisingly named ```TranslationContainer```.\r\n\r\nCreate containers or translation items beneath the main translation container. \r\n\r\nA container for category translations is best created directly underneath the main translation container.\r\n\r\n## Code specifics\r\n\r\nFor the basics for initializing a localization provider from code read the [SDK](http://sdkbeta.episerver.com/SDK-html-Container/?path=/SdkDocuments/EPiServerFramework/7/Knowledge%20Base/Developer%20Guide/Localization/CustomLocalizationProvider.htm&vppRoot=/SdkDocuments//EPiServerFramework/7/Knowledge%20Base/Developer%20Guide/).\r\n\r\nAfter the basic things as described in the SDK you will need to load the translations into the provider after initializing, publishing, moving and deleting. The xml that gets generated will change on these events, so the provider needs to be reloaded. Kinda like a file dependency.\r\n\r\nIn  the initialization module you need to attach some events.\r\n\r\n* ```context.InitComplete += this.InitComplete;```\r\n* ```DataFactory.Instance.PublishedPage += InstanceChangedPage;```\r\n* ```DataFactory.Instance.MovedPage += InstanceChangedPage;```\r\n* ```DataFactory.Instance.DeletedPage += InstanceChangedPage;```\r\n\r\nIn the attached events I retrieve the translations as an the xml structure, in the same format as a lang file, then I load the generated xml into the ```LanguageDocument``` from the provider, which is  where a ```XmlLocalizationProvider``` stores  it’s data.\r\n\r\n```\r\nstring translations = TranslationFactory.Instance.GetXDocument();\r\nbyte[] byteArray = Encoding.Unicode.GetBytes(translations);\r\n \r\nusing (MemoryStream stream = new MemoryStream(byteArray))\r\n{\r\n      this.Load(stream);\r\n}\r\n```\r\n\r\nThe xml is created by looping through the translation containers and the translation items for each language the main translation container is created in. The format is that of a normal lang file.\r\n\r\nYou can use these translations like any other translation. ```<EPiServer:Translate runat=\"server\" Text=\"/jeroenstemerdink/textone\" />```\r\n\r\nIf you want to display a translated category on your page use the ```LocalizedDescription``` property of the ```Category```.\r\n\r\n## Quirks\r\n\r\nA few things you will need to keep in mind.\r\n\r\nWhen you create a translation the ```OriginalText``` is the key, and can only be set on the master language. To keep it simple for the editors just name them normally. \r\nTo reference this, use the name without spaces and special characters, all lower case, this to be in line with the langfiles.\r\n\r\nSo if the Name of the container is e.g. ```Jeroen Stemerdink```, the key in the xml will be ```jeroenstemerdink```. The same applies to the translation items.\r\n\r\nSee ```Bonus``` for a tip on how to get the key in an easy way.\r\n\r\nFor translations for Categories it is slightly different. You create a ```CategoryTranslationContainer``` beneath the main container, this will trigger a different rendering of the xml.  \r\nYou can organize the translations with subcontainers, but in the xml those subcontainers will not be used. \r\nThe value of the ```OriginalText``` property needs to be exactly the same as the name of the ```Category``` you want to translate.\r\n\r\n## Bonus\r\n\r\nOn the “TranslationItem” I have added three properties you can use on a template, if you create one for a translation that is. You will not use it in the site, but it can display a few things using those properties.\r\n* ```MissingValues```:  the languages that have no translation yet.\r\n* ```LookupKey```: the key to use in e.g. the Translate WebControl.\r\n* ```TranslatedValues```:  a dictionary containing the language and the translation.\r\n\r\n\r\n## Requirements\r\n\r\n* EPiServer 7\r\n* log4net\r\n* .Net 4.5 (You can use 4.0, but will need to change some property types, the ```ReadOnly collections``` on the ```TransLationItem```,\r\n\r\n## Deploy\r\n\r\n* Compile the project. \r\n* Drop the dll in the bin.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}